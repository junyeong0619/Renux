# Renux: C언어 기반 원격 리눅스 관리 도구

 

**Renux**는 원격 리눅스 시스템의 상태를 확인하고 관리하기 위해 개발된 클라이언트-서버 기반의 원격 관리 도구입니다. C언어의 시스템 프로그래밍과 소켓 통신을 기반으로 구현되었으며, `ncurses` 라이브러리를 활용한 텍스트 기반 사용자 인터페이스(TUI)를 통해 터미널 환경에서도 사용자 친화적인 경험을 제공합니다.

## 📋 주요 기능

  - **사용자 인증**: 안전한 접속을 위한 로그인 기능을 제공합니다.
  - **시스템 사용자 정보 조회**: 서버에 등록된 사용자 목록을 실시간으로 확인하고 상세 정보를 열람할 수 있습니다.
  - **원격 쉘 명령어 실행**: `ls`와 같이 간단한 쉘 명령어를 원격 서버에서 실행하고 결과를 즉시 확인할 수 있습니다.
  - **TUI 기반 상호작용**: 메뉴 시스템을 통해 사용자 목록 조회 및 관리 기능을 손쉽게 선택하고 실행할 수 있습니다.

## 🛠️ 주요 사용 기술

### 1\. C 언어 및 시스템 프로그래밍

C언어는 리눅스의 저수준(low-level) API에 직접 접근하여 시스템을 제어하고, 메모리를 효율적으로 관리하여 성능을 최적화하는 데 가장 적합하여 채택했습니다.

  - **`pwd.h`**: `getpwent`, `setpwent`, `endpwent` 함수를 사용하여 `/etc/passwd` 파일의 사용자 정보를 순차적으로 읽어오는 데 사용했습니다.
  - **`popen`, `pclose`**: `ls`, `awk`와 같은 쉘 명령어를 서버에서 실행하고, 그 결과를 파이프(pipe)로 읽어와 클라이언트에 동적인 정보를 전달하는 기능을 구현했습니다.
  - **`__builtin_expect`**: GCC 확장 기능을 활용, `likely(x)`와 `unlikely(x)` 매크로를 정의하여 컴파일러에 분기 예측 정보를 제공함으로써 코드 실행을 미세하게 최적화했습니다.

### 2\. Linux/POSIX 소켓 프로그래밍 (TCP/IP)

클라이언트와 서버 간의 안정적인 양방향 통신을 위해 TCP/IP 기반의 소켓 프로그래밍을 활용했습니다.

  - **서버**: `socket()` → `bind()` → `listen()` → `accept()` 순서로 클라이언트의 접속 요청을 수락하고 통신을 위한 소켓을 생성합니다.
  - **클라이언트**: `socket()` → `connect()` 순서로 서버에 연결을 시도합니다.
  - **데이터 송수신**: `send()`/`write()` 및 `read()` 함수를 사용하여 양방향으로 데이터를 주고받습니다.

### 3\. Ncurses 라이브러리 (TUI 구현)

터미널 환경에서 그래픽 인터페이스(GUI)와 유사한 사용자 경험을 제공하기 위해 `ncurses` 라이브러리를 사용했습니다.

  - **화면 분할**: `newwin()` 함수로 서버 로그, 명령어 입력, 메시지 수신 창 등을 독립적으로 관리하여 화면을 체계적으로 구성했습니다.
  - **자동 스크롤**: `scrollok()` 함수를 활성화하여 메시지가 창 크기를 벗어날 때 자동으로 스크롤되도록 구현했습니다.
  - **상호작용 메뉴**: `keypad()`, `wgetch()` 등을 활용하여 사용자가 화살표 키로 항목을 선택하는 동적인 메뉴 시스템을 구축했습니다.

### 4\. 멀티스레딩 (Pthreads)

클라이언트가 서버로부터 메시지를 수신하는 동안에도 사용자의 입력을 받아 명령을 전송할 수 있도록 비동기적 처리를 위해 멀티스레딩을 도입했습니다.

  - **스레드 생성**: `pthread_create()`를 사용하여 서버로부터 오는 메시지를 전담 처리하는 수신 스레드(`receive_handler`)를 생성합니다.
  - **역할 분리**: 메인 스레드는 사용자 입력을 처리하여 서버로 전송하고, 수신 스레드는 서버의 응답을 받아 화면에 출력하는 역할을 담당합니다.
  - **동기화**: `pthread_mutex_t`를 사용하여 여러 스레드가 공유 자원(`menu_user_list`)에 동시에 접근할 때 발생할 수 있는 경쟁 상태(race condition)를 방지하고 데이터 일관성을 유지합니다.

## 📁 프로젝트 구조

```
.
├── server/
│   ├── server.c         # 메인 서버 로직 (소켓 생성, 연결 및 인증 처리)
│   ├── service.c        # 클라이언트 요청에 대한 실제 기능 수행
│   └── tui.c, tui.h     # 서버용 TUI 관련 함수
└── client/
    ├── client.c         # 메인 클라이언트 로직 (서버 접속, UI, 스레드 생성)
    └── tui.c, tui.h     # 클라이언트용 TUI 관련 함수 (채팅, 메뉴 구현)
```

## ⚙️ 주요 기능 구현 상세

### 사용자 인증 (Login)

1.  클라이언트가 `사용자이름,비밀번호` 형식의 문자열을 서버로 전송합니다.
2.  서버의 `login_process` 함수는 `strtok`으로 문자열을 분리합니다.
3.  `is_valid_login` 함수가 `getlogin()`으로 얻은 서버 실행 사용자의 이름과 클라이언트가 보낸 이름을 비교하고, 설정된 비밀번호와 일치하는지 확인하여 인증을 수행합니다.

### 사용자 목록 조회 및 관리 (`getu`, `manage`)

1.  **조회 (`getu`)**:
      - 클라이언트가 `getu`를 입력하면, 서버는 `popen("awk -F: '{print $1}' /etc/passwd", "r")`를 실행하여 사용자 목록을 얻습니다.
      - 서버는 결과를 한 줄씩 클라이언트로 전송하고, 마지막에 "END\_OF\_LIST"를 보내 전송 완료를 알립니다.
      - 클라이언트의 수신 스레드는 "END\_OF\_LIST"를 받기 전까지 모든 사용자 이름을 배열(`menu_user_list`)에 저장합니다.
2.  **관리 (`manage`)**:
      - 클라이언트가 `manage`를 입력하면, `show_user_menu` 함수가 `menu_user_list`에 저장된 목록을 TUI 메뉴로 출력합니다.
      - 사용자가 특정 유저를 선택하면, `user_manage_function_selections` 함수가 호출되어 추가 기능(샘플 1, 2, 3)을 선택하는 2차 메뉴가 나타납니다.

## 🚀 향후 개선 과제

  - **데이터 암호화**: 현재 평문으로 통신하는 데이터를 `OpenSSL` 라이브러리 등을 적용하여 SSL/TLS 암호화를 추가할 계획입니다.
  - **실시간 작업 현황 보고**: 서버에서 오래 걸리는 작업이 실행될 경우, 클라이언트가 작업 진행 상황을 알 수 있도록 주기적인 보고 기능을 추가할 예정입니다.
  - **오류 처리 강화**: 소켓 연결 끊김, 데이터 수신 실패 등 다양한 예외 상황에 대한 처리를 보강하여 프로그램의 안정성을 높일 것입니다.

## 🏁 시작하기

### 사전 요구 사항

  - `gcc` 컴파일러
  - `ncurses` 라이브러리 (`libncurses-dev` 또는 `ncurses-devel` 패키지)

### 빌드 및 실행

1.  **저장소 복제**

    ```sh
    git clone https://github.com/junyeong0619/Renux.git
    cd Renux
    ```

2.  **컴파일**

    ```sh
    # Makefile을 사용하여 서버와 클라이언트를 빌드합니다.
    make
    ```

3.  **실행**

      - **서버 실행**:
        ```sh
        ./server <port> <password>
        ```
      - **클라이언트 실행**:
        ```sh
        ./client <server_ip> <port>
        ```
