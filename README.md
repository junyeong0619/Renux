
# **Renux: C언어 기반 원격 리눅스 관리 도구**

**Renux**는 원격 리눅스 시스템의 상태를 확인하고 관리하기 위해 개발된 클라이언트-서버 기반의 원격 관리 도구입니다. C언어 시스템 프로그래밍과 소켓 통신을 기반으로 구현되었으며, `ncurses` 라이브러리를 활용한 텍스트 기반 사용자 인터페이스(TUI)를 통해 터미널 환경에서도 사용자 친화적인 경험을 제공합니다.

## 📋 **주요 기능**

  * **보안 인증**: 서버 시작 시 설정된 비밀번호를 **해시(Hash)로 저장**하고, 클라이언트가 전송한 비밀번호를 해싱하여 비교하는 안전한 로그인 기능을 제공합니다.
  * **시스템 정보 조회**: 서버에 등록된 사용자 목록, 특정 사용자의 상세 정보(UID, GID, 홈 디렉토리 등), 프로세스 목록, 디스크 사용량(쿼터) 등 다양한 시스템 정보를 실시간으로 조회할 수 있습니다.
  * **원격 시스템 관리**: 사용자의 디스크 쿼터(Soft/Hard Limit)를 원격으로 설정하는 등 간단한 관리 기능을 수행합니다.
  * **비동기 통신**: 클라이언트에서 **멀티스레딩**을 적용하여, 서버로부터 실시간으로 메시지를 수신하면서 동시에 사용자 명령을 입력하고 전송할 수 있습니다.
  * **TUI 기반 상호작용**: `ncurses` 기반의 동적인 메뉴 시스템을 통해 사용자 목록을 보고 화살표 키로 선택하는 등 직관적인 조작이 가능합니다.
  * **고성능 이벤트 처리**: 서버는 macOS의 **`kqueue`** 또는 리눅스의 \*\*`epoll`\*\*을 사용하여 다수의 클라이언트 요청을 효율적으로 처리하는 이벤트 기반 아키텍처로 설계되었습니다.

## 🛠️ **주요 사용 기술**

### **1. C 언어 및 시스템 프로그래밍**

C언어는 리눅스의 저수준(low-level) API에 직접 접근하여 시스템을 제어하고, 메모리를 효율적으로 관리하여 성능을 최적화하는 데 가장 적합하여 채택했습니다.

  * **`pwd.h`**: `getpwent`, `getpwnam` 함수를 사용하여 `/etc/passwd` 파일의 사용자 정보를 조회하는 데 사용했습니다.
  * **`popen`, `pclose`**: `awk`, `ps`, `quota`와 같은 쉘 명령어를 서버에서 실행하고, 그 결과를 파이프로 읽어와 클라이언트에 동적인 정보를 전달하는 기능을 구현했습니다.
  * **`__builtin_expect`**: GCC 확장 기능을 활용, `likely(x)`와 `unlikely(x)` 매크로를 정의하여 컴파일러에 분기 예측 정보를 제공함으로써 코드 실행을 미세하게 최적화했습니다.

### **2. Linux/POSIX 소켓 프로그래밍 (TCP/IP)**

클라이언트와 서버 간의 안정적인 양방향 통신을 위해 TCP/IP 기반의 소켓 프로그래밍을 활용했습니다.

  * **서버**: `socket()` → `bind()` → `listen()` → `accept()` 순서로 클라이언트의 접속 요청을 수락하고 통신을 위한 소켓을 생성합니다.
  * **클라이언트**: `socket()` → `connect()` 순서로 서버에 연결을 시도합니다.
  * **데이터 송수신**: `send()` 및 `read()` 함수를 사용하여 양방향으로 데이터를 주고받습니다.

### **3. Ncurses 라이브러리 (TUI 구현)**

터미널 환경에서 그래픽 인터페이스(GUI)와 유사한 사용자 경험을 제공하기 위해 `ncurses` 라이브러리를 사용했습니다.

  * **화면 분할**: `newwin()` 함수로 서버 로그, 명령어 입력, 메시지 수신 창 등을 독립적으로 관리하여 화면을 체계적으로 구성했습니다.
  * **자동 스크롤**: `scrollok()` 함수를 활성화하여 메시지가 창 크기를 벗어날 때 자동으로 스크롤되도록 구현했습니다.
  * **상호작용 메뉴**: `keypad()`, `wgetch()` 등을 활용하여 사용자가 화살표 키로 항목을 선택하는 동적인 메뉴 시스템을 구축했습니다.

### **4. 멀티스레딩 (Pthreads)**

클라이언트가 서버로부터 메시지를 수신하는 동안에도 사용자의 입력을 받아 명령을 전송할 수 있도록 비동기적 처리를 위해 멀티스레딩을 도입했습니다.

  * **스레드 생성**: `pthread_create()`를 사용하여 서버로부터 오는 메시지를 전담 처리하는 수신 스레드(`receive_handler`)를 생성합니다.
  * **역할 분리**: 메인 스레드는 사용자 입력을 처리하여 서버로 전송하고, 수신 스레드는 서버의 응답을 받아 화면에 출력하는 역할을 담당합니다.
  * **동기화**: `pthread_mutex_t`를 사용하여 여러 스레드가 공유 자원(`menu_user_list`)에 동시에 접근할 때 발생할 수 있는 경쟁 상태(race condition)를 방지하고 데이터 일관성을 유지합니다.

## 📁 **프로젝트 구조**

```
.
├── server/
│   ├── server.c         # 메인 서버 로직 (소켓 생성, kqueue/epoll 이벤트 처리, 인증)
│   ├── service.c        # 클라이언트 요청에 대한 실제 기능 수행 (e.g., getu, getinfo)
│   └── tui.c, tui.h     # 서버용 TUI 관련 함수
├── client/
│   ├── client.c         # 메인 클라이언트 로직 (서버 접속, UI, 스레드 생성)
│   └── tui.c, tui.h     # 클라이언트용 TUI 관련 함수 (채팅, 메뉴 구현)
└── utils/
    ├── ssl_utils.c      # 비밀번호 해싱 함수 구현
    ├── log.c            # 파일 로깅 관련 함수 구현
    └── ...
```

## ⚙️ **주요 기능 구현 상세**

### **사용자 인증 (Login)**

1.  서버는 시작 시 관리자 비밀번호를 입력받아 `hash_string` 함수로 해싱하여 보관합니다.
2.  클라이언트가 `사용자이름,비밀번호` 형식의 문자열을 서버로 전송합니다.
3.  서버의 `is_valid_login` 함수는 전송된 비밀번호를 동일하게 해싱한 후, 저장된 해시값과 비교하여 인증을 수행합니다.

### **사용자 목록 조회 및 관리 (`getu`, `manage`)**

1.  **조회 (`getu`)**:
      * 클라이언트가 `getu`를 입력하면, 서버는 `popen("awk -F: '{print $1}' /etc/passwd", "r")`를 실행하여 사용자 목록을 얻습니다.
      * 서버는 결과를 한 줄씩 클라이언트로 전송하고, 마지막에 "END\_OF\_LIST"를 보내 전송 완료를 알립니다.
      * 클라이언트의 수신 스레드는 "END\_OF\_LIST"를 받기 전까지 모든 사용자 이름을 동적 배열(`menu_user_list`)에 저장합니다.
2.  **관리 (`manage`)**:
      * 클라이언트가 `manage`를 입력하면, `show_user_menu` 함수가 `menu_user_list`에 저장된 목록을 TUI 메뉴로 출력합니다.
      * 사용자가 특정 유저를 선택하면, `user_manage_function_selections` 함수가 호출되어 추가 기능("Get user information" 등)을 선택하는 2차 메뉴가 나타납니다.

## 🚀 **향후 개선 과제**

  * **데이터 암호화**: 현재 평문으로 통신하는 데이터를 `OpenSSL` 라이브러리 등을 적용하여 SSL/TLS 암호화를 추가할 계획입니다.
  * **실시간 작업 현황 보고**: 서버에서 오래 걸리는 작업이 실행될 경우, 클라이언트가 작업 진행 상황을 알 수 있도록 주기적인 보고 기능을 추가할 예정입니다.
  * **오류 처리 강화**: 소켓 연결 끊김, 데이터 수신 실패 등 다양한 예외 상황에 대한 처리를 보강하여 프로그램의 안정성을 높일 것입니다.

## 🏁 **시작하기**

### **사전 요구 사항**

  * `gcc` 컴파일러
  * `ncurses` 라이브러리 (`libncurses-dev` 또는 `ncurses-devel` 패키지)
  * `pthreads` 라이브러리

### **빌드 및 실행**

1.  **저장소 복제**

    ```sh
    git clone https://github.com/junyeong0619/Renux.git
    cd Renux
    ```

2.  **컴파일**

    ```sh
    # Makefile을 사용하여 서버와 클라이언트를 빌드합니다.
    make
    ```

3.  **실행**

      * **서버 실행**:

        ```sh
        ./server_e
        ```

        *(실행 후 터미널 안내에 따라 비밀번호를 설정합니다)*

      * **클라이언트 실행** (다른 터미널에서):

        ```sh
        ./client_e <server_ip> <port>
        ```

        *(예: `./client_e 127.0.0.1 8080`)*
